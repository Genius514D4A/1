# common logging configuration see common scala
include "logging"
include "akka-http-version"

whisk {
  loadbalancer {
    invoker-busy-threshold: 4
    blackbox-fraction: 10%
  }
  controller {
    protocol: http
  }
  cluster {
    use-cluster-bootstrap: false #true enables use of Akka Management + Akka Cluster Bootstrap; otherwise, static list of seed nodes is required
  }
}

# http://doc.akka.io/docs/akka-http/current/scala/http/configuration.html
# descriptions inlined below for convenience
akka.http {
  server {
    # Description:
    # If a request hasn't been responded to after the time period set here
    # a `akka.http.Timedout` message will be sent to the timeout handler.
    # Set to `infinite` to completely disable request timeouts.
    #
    # Explaining the set value:
    # The controller holds connections up to 60s for blocking invokes, and
    # all other operations are expected to complete quickly. We allow a grace
    # period in addition to the blocking invoke timeout.
    request-timeout = 65s

    # The maximum number of concurrently accepted connections when using the
    # `Http().bindAndHandle` methods.
    #
    # This setting doesn't apply to the `Http().bind` method which will still
    # deliver an unlimited backpressured stream of incoming connections.
    #
    # Note, that this setting limits the number of the connections on a best-effort basis.
    # It does *not* strictly guarantee that the number of established TCP connections will never
    # exceed the limit (but it will be approximately correct) because connection termination happens
    # asynchronously. It also does *not* guarantee that the number of concurrently active handler
    # flow materializations will never exceed the limit for the reason that it is impossible to reliably
    # detect when a materialization has ended.
    max-connections = 8192

    # Description:
    # Enables/disables support for statistics collection and querying.
    # Even though stats keeping overhead is small,
    # for maximum performance switch off when not needed.
    stats-support = off

    # Description:
    # The time after which an idle connection will be automatically closed.
    # Set to `infinite` to completely disable idle connection timeouts.
    #
    # Explaining the set value:
    # This must be greater than the request timeout.
    idle-timeout = 70s

    parsing {
      # This indirectly puts a bound on the name of entities
      # 8k matches nginx default
      max-uri-length = 8k

      # This is 50MB to allow action attachments
      max-content-length = 50m
    }
  }
}

# Check out all akka-remote-2.5.4 options here:
# http://doc.akka.io/docs/akka/2.5.4/scala/general/configuration.html#config-akka-remote
akka {
  remote {
    log-remote-lifecycle-events = DEBUG
    log-received-messages = on
    log-sent-messages = on
  }
  cluster {
    # Disable legacy metrics in akka-cluster.
    metrics.enabled=off

    #distributed-data.notify-subscribers-interval = 0.01
  }
}
akka {
  discovery {
    #method = marathon-api
    marathon-api {
      class = akka.discovery.marathon.MarathonApiSimpleServiceDiscovery

      # URL for getting list of apps from Marathon. Verified on OSS DC/OS 1.8, 1.9
      app-api-url = "http://192.168.99.100:8080/v2/apps"

      # The name of the akka management port - this cannot have underscores or dashes (env var name)
      app-port-name = "akkamgmthttp"

      # Used to find other apps running by Marathon. This will be passed as the label query string parameter
      # to the apps-api-url defined above.
      # `%s` will be replaced with the configured effective name, which defaults to the actor system name
      app-label-query = "ACTOR_SYSTEM_NAME==%s"
    }
  }

  management {
    http {
      # The hostname where the HTTP Server for Http Cluster Management will be started.
      # This defines the interface to use.
      # InetAddress.getLocalHost.getHostAddress is used not overriden or empty
      hostname = ${HOST}
      port = 19999
      port = ${?PORT_19999}

      bind-hostname = 0.0.0.0
      bind-port = 19999
    }

    cluster.bootstrap {

      # Configuration for the first phase of bootstraping, during which contact points are discovered
      # using the configured service discovery mechanism.
      contact-point-discovery {

        # Marathon API discovery uses effective-name when it's defined.
        #
        # Marathon API dicsovery uses this value to substitute to the query `app-label-query`
        #
        # It should match with application LABEL value declared in Marathon description.
        #
        effective-name= "whisk-controller-docker-app-label"
      }

    }
  }
}
