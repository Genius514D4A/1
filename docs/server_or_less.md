# Should you be using Serverless?

Serverless architecture is not a panacea to all computing problems, but it does solve some. There are [many uses cases](use_cases.md) when serverless design may be a good choice. Here we will compare the following architectures:

[OpenWhisk on Bluemix](https://console.ng.bluemix.net/openwhisk) **Function as a Service (FaaS)** from IBM.
OpenWhisk Roll Your Own (RYO) on any **Infrastructure as a Service (IaaS)** cloud - end user can download OpenWhisk from Apache Incubation Project and install and run it on [Bluemix IaaS](https://console.ng.bluemix.net/catalog/?category=devices), [Amazon EC2](https://aws.amazon.com/ec2), [Google GCE](https://cloud.google.com/products/compute), [Microsoft Azure](https://azure.microsoft.com/en-us/services/virtual-machines), or other [IaaS cloud](https://en.wikipedia.org/wiki/Cloud_computing#Infrastructure_as_a_service_.28IaaS.29).
[CloudFoundry Runtime Applications on Bluemix](https://console.ng.bluemix.net/catalog/?category=runtimes) **Platform as a Service runtimes (PaaS)**  from IBM. A good example is [Liberty for Java](https://console.ng.bluemix.net/catalog/starters/liberty-for-java) runtime.
[Containers on Bluemix](https://console.ng.bluemix.net/catalog/?category=containerImages) **Container as a Service (CaaS)** from IBM.
[WebSphere Application Server VM on Bluemix](https://console.ng.bluemix.net/catalog/services/websphere-application-server) from IBM.

Here is a summary of pros and cons of each architecture choice from the **perspective of an end users** who are developing and operating applications on these different runtimes:

|  | (1) OpenWhisk FaaS on Bluemix | (2) OpenWhisk RYO on IaaS | (3) CF PaaS on Bluemix | (4) CaaS on Bluemix | (5) WAS VM on Bluemix |
| --- | --- | --- | --- | --- | --- |
| Resource footprint | None | High | None from end user perspective, however internally there is some footprint | Small to Medium | High - end user has to pay for the footprint whether it is all utilized or not |
| Installation and setup | None required | Hard - all done by the end user | None required | Moderate - hw, networking, OS, container mgmt tools provided by IBM, images, connectivity and instances by end user | Hard - hw, networking, OS, initial WAS install provided by IBM, additional configuration, clustering, scaling by end user |
| Ongoing administration | None | Hard | None | Moderate | Hard |
| Elastic scaling | Each action is always instantly and automatically scaled depending on the load | Not provided - end user must provide compute capacity and manage scaling | Automatic, but slow scaling. At the start of a peak for several minutes users may be waiting for scale action to complete | Semi-automatic, but slow scaling. At the start of a peak for several minutes users may be waiting for scale action to complete | Not provided |
| Capacity planning | Not needed. FaaS will automatically provide as much capacity as needed | Need to provision enough capacity in advance or script it | Some capacity planning is needed, but some automatic capacity increase is provided | Some capacity planning is needed, but some automatic capacity increase is provided | Need to statically provision enough capacity to handle for peak workload |
| Persistent connections and state | Not supported - can not keep a persistent connection. State must be kept in external resource | Not supported - can not keep a persistent connection. State must be kept in external resource | Supported - can keep an open socket or connection for long times, can store state in memory between calls | Supported - can keep an open socket or connection for long times, can store state in memory between calls | Supported - can keep an open socket or connection for long times, can store state in memory between calls |
| Maintenance | Not required - entire stack is managed by IBM | Significant - depending on the target environment, user must provision hw, networking, OS, storage, DB, install and maintain OpenWhisk, etc. | Not required - entire stack is managed by IBM | Significant - user must create and maintain custom images, deploy and manage containers, connections between containers, etc. | Significant - user must allocate VMs, manage and scale WAS in a traditional way |
| High Availability (HA) and Disaster Recovery (DR) | Inherent / no extra costs | Roll your own (RYO) | Available at extra cost | Failed containers can be automatically restarted | Available at extra cost, semi-automatic. VMs can be automatically failed over |
| Security | Vendor provided | Roll your own (RYO) | Mix of RYO and vendor provided | Mix of RYO and vendor provided | Roll your own (RYO) |
| Developer velocity | Highest | Highest | Highest | Average | Slow |
| Idle resources that still needs to be paid for | Resources are never “idle” as they are invoked only when there is a request. When there is no workload, there is no resource allocation and no cost | Very likely this will be using IaaS or CaaS and similar considerations apply as in columns (4) and (5) | Stopped instances do not cost anything. Running instances are likely to be used at less than 50% of their capacity | Stopped instances do not cost anything. Running instances are likely to be used at less than 50% of their capacity | VMs that are shut down are paid at 5% of full cost. Running VMs are likely to be used at less than 50% of their capacity |
| Maturity | Early maturity | Early maturity | Early maturity | Moderate maturity | Very mature |
| Resource limits | [Some limits exist](./reference.md#system-limits) | Depends on allocated resources | No | No | No |
| Latency for rarely used services | Rare requests may initially see several seconds response time, but will be in ms range for subsequent requests | Depends | Very low | Very low | Very low - assuming the system has enough resources |
| Sweet spot type of application | Event processing, IoT, Mobile backend, microservices. Definitely not for monolithic applications. See [use cases](./use_cases.md) | Same as col (1), but when user wants to run on non-IBM cloud or run on-prem. | Web applications with 24x7 workload load, stateful services that need to keep the connection open for long periods of time. Can be used to run microservices or monolithic applications | Well suited for microservices applications. | Traditional enterprise applications migrated from on-prem to the cloud. Better suited for monolithic applications |
| Billing | [Per blocks of 100 milliseconds](https://console.ng.bluemix.net/openwhisk/learn/pricing) | Depends | Per hour | Per hour or per minute | Per hour or per minute |
| Total Cost of Ownership (TCO) | For its “sweet spot” applications is likely to cost order of magnitude less than alternatives. Because resources are auto scaled, there is never an issue of overprovisioning | For cloud deployments this is likely to be more expensive than OpenWhisk FaaS, but for on-prem deployment can be cheaper than traditional architectures | Relatively low - the user does not need to provision or manage resources and only needs to worry his application, but there is some level of overprovisioning compared to serverless | Moderate - the user needs to provision and manage containers and application, but there is some level of overprovisioning compared to serverless and compared to PaaS | Relatively high, but considering that migration of legacy applications into cloud native model could be prohibitively expensive, this may be a viable and economical choice for those apps |

For a more comprehensive discussion of traditional vs serverless architecture, please refer to [Mike Robert post on Martin Fowler’s blog](https://martinfowler.com/articles/serverless.html).
